/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <alibaba_combine_symbols_bb.h>
#include <gr_io_signature.h>

/*
 * Create a new instance of alibaba_combine_symbols_bb and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
alibaba_combine_symbols_bb_sptr 
alibaba_make_combine_symbols_bb (int min_number_of_symbols_representing_one_binary_value, int max_number_of_symbols_representing_one_binary_value)
{
  return alibaba_combine_symbols_bb_sptr (new alibaba_combine_symbols_bb (min_number_of_symbols_representing_one_binary_value, max_number_of_symbols_representing_one_binary_value));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 1;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
alibaba_combine_symbols_bb::alibaba_combine_symbols_bb (int min_number_of_symbols_representing_one_binary_value, int max_number_of_symbols_representing_one_binary_value)
  : gr_block ("alibaba_combine_symbols_fch",
	      gr_make_io_signature (MIN_IN, MAX_IN, sizeof (char)),
	      gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (char)))
{
	max_num=max_number_of_symbols_representing_one_binary_value;
        min_num=min_number_of_symbols_representing_one_binary_value;
        init=0;
        counter=0;
        symbol=0;
}

/*
 * Our virtual destructor.
 */
alibaba_combine_symbols_bb::~alibaba_combine_symbols_bb ()
{
}

int alibaba_combine_symbols_bb::printsymbols(char *output_file, int file_position, int counter, char symbol)
{
	int num_symbols=0;
        int difference=max_num-min_num;
            

        if((counter >= min_num) && (counter <=max_num))
        {
                num_symbols=1;
        }
	else if((counter >=((max_num-difference)*2)) && (counter <= (max_num*2)))
        {
                num_symbols=2;
        }
	else if((counter >=((max_num-difference)*3)) && (counter <=(max_num*3)))
        {
                num_symbols=3;
        }                                                                                                                                                                                                                                                       
	else if((counter >=((max_num-difference)*4)) && (counter <= (max_num*4)))
        {
                num_symbols=4;
        }

        for(int i=0;i<num_symbols;i++)
        {
                output_file[file_position]= symbol;
                file_position++;
        }

        return file_position;
}


int 
alibaba_combine_symbols_bb::general_work (int noutput_items,
			       gr_vector_int &ninput_items,
			       gr_vector_const_void_star &input_items,
			       gr_vector_void_star &output_items)
{
  const char *in = (const char *) input_items[0];
  char *out = (char *) output_items[0];
  char tmp_input= 0;
  int output_position=0;

   //I don't know if it is the best way to combine symbols,
   //but it works reasonably well. So, no need for me to find a better algorithm...

  for (int i = 0; i < noutput_items; i++)
  {
        tmp_input= in[i];
        if(tmp_input==1 || tmp_input==0)
	{
                if(init==0) //synchronise symbol and input at the very begining
	        {
		        init=1;
		        symbol=tmp_input;
	        }

	        //check the cases:
	        if(tmp_input==0 && symbol==0)
	        {
	        	counter++; //symbol was already 0, another 0, counter++
	        }
	        else if(tmp_input==0 && symbol==1)//transition from 1 to 0, counter=1 (for the current symbol), symbol=0; print appropriate number of 1-bits to file
	        { 
                        if(tmp_input==in[i+1]) //to compensate false reads. if only one symbol is wrong, ignore it!
                        {
                                output_position=printsymbols(out,output_position, counter,symbol);
                                symbol=0;
                                counter=1; 
                        }
                        else counter++;
	        }
	        else if(tmp_input==1 && symbol==1)
	        {
	        	counter++; //symbol was already 1, another 1, counter++
	        }
	        else if(tmp_input==1 && symbol==0)//transition from 0 to 1, counter=1 (for the current symbol), symbol=1; print appropriate number of 0-bits to file
	        {
	        	if(tmp_input==in[i+1]) //to compensate false reads. if only one symbol is wrong, ignore it!
                        {
                                output_position=printsymbols(out, output_position, counter,symbol);
                                symbol=1;
                                counter=1; 
                        } 
                        else counter++;
	        }
        
        }
        else 
        {
                output_position=printsymbols(out, output_position, counter,symbol);
                init=0;
                counter=0;
                out[output_position++]=tmp_input;
        }
  }
  
  //FIXME very last symbol in a stream meight not be printed, although valid! 
  //Does not really effect a long stream, but still...


  // Tell runtime system how many input items we consumed on
  // each input stream.

  consume_each (noutput_items);

  // Tell runtime system how many output items we produced.
  return output_position;
}

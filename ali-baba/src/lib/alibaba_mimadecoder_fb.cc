/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <alibaba_mimadecoder_fb.h>
#include <gr_io_signature.h>

#define ENCODING_MANCHESTER 1
#define ENCODING_MILLER 2

#define TAG_ID_LENGTH 4

#define ENCODING_UNKNOWN -1

#define FREQUENCY_ERROR 0

/*
 * Create a new instance of alibaba_mimadecoder_fb and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
alibaba_mimadecoder_fb_sptr 
alibaba_make_mimadecoder_fb (float sampling_frequency, float data_rate, float thres_mi, float thres_ma, char decode_miller_or_manchester, float block_separation_value, char separation_value_for_miller, char separation_value_for_manchester, bool enable_parity_check, bool enable_crc_check, int* send_state)
{
  return alibaba_mimadecoder_fb_sptr (new alibaba_mimadecoder_fb (sampling_frequency, data_rate, thres_mi, thres_ma, decode_miller_or_manchester, block_separation_value, separation_value_for_miller, separation_value_for_manchester, enable_parity_check, enable_crc_check, send_state));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 1;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
alibaba_mimadecoder_fb::alibaba_mimadecoder_fb (float sampling_frequency, float data_rate, float thres_mi, float thres_ma, char decode_miller_or_manchester, float block_separation_value, char separation_value_for_miller, char separation_value_for_manchester, bool enable_parity_check, bool enable_crc_check, int* send_state)
  : gr_block ("mimadecoder_fb",
	      gr_make_io_signature (MIN_IN, MAX_IN, sizeof (float)),
	      gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (short)))
{
  	sampling_frequency_=sampling_frequency;
  	data_rate_=data_rate;
        samples_per_symbol_=rint(sampling_frequency_/data_rate_);
  	thres_mi_=thres_mi;
        thres_ma_=thres_ma;
  	separation_val_=block_separation_value;
        separation_value_for_miller_=separation_value_for_miller;
        separation_value_for_manchester_=separation_value_for_manchester;
        decode_miller_or_manchester_=decode_miller_or_manchester;
        enable_parity_check_=enable_parity_check;
        enable_crc_check_=enable_crc_check;
        state=0;
        last_symbol=0;
        encoding_scheme=ENCODING_UNKNOWN;
        tmp_buffer.clear();
        tmp_out_buffer.clear();
        out_buffer.clear();
        initial_fill=false;
        initial_fill_count=0;
        split_block=false;

        //FIXME send state for enabling synchronization between sender and receiver not used yet!
        send_state_=send_state;
}


unsigned short alibaba_mimadecoder_fb::UpdateCrc(unsigned char ch, unsigned short *lpwCrc)
{
  ch = (ch^(unsigned char)((*lpwCrc) & 0x00FF));
  ch = (ch^(ch<<4));
  *lpwCrc = (*lpwCrc >> 8)^((unsigned short)ch << 8)^((unsigned
short)ch<<3)^((unsigned short)ch>>4);
  return(*lpwCrc);
}


void alibaba_mimadecoder_fb::ComputeCrc(unsigned char *Data, int Length,
  unsigned char *TransmitFirst, unsigned char *TransmitSecond)
{
  unsigned char chBlock;
  unsigned short wCrc=0x6363; //Initial value for 14443-A CRC!

  do {
    chBlock = *Data++;
    UpdateCrc(chBlock, &wCrc);
  } while (--Length);

  *TransmitFirst = (unsigned char) (wCrc & 0xFF);
  *TransmitSecond = (unsigned char) ((wCrc >> 8) & 0xFF);
  return;
}

/**
 * handle Iso 14443 commands, that are only 7 bit long.
 * Supported commands: Req-A (0x26), Wake-up (0x52), optional time slot (0x35) 
 * Returns the command, if present, or 0 if not...
 */
short alibaba_mimadecoder_fb::convertSevenBitCommandsIntoBytes(std::vector<char> buffer) //FIXME accept all one bit commands!
{
        unsigned char tmp_item=0;
        for(int k=0;k<buffer.size();k++)
                tmp_item=tmp_item | buffer[k] << k;
        //if(tmp_item==0x26 || tmp_item== 0x52 || tmp_item== 0x35) //Iso 14443 Req-A (26), Wake-up (52), optional time slot (35) 
        return tmp_item;
        //return 0;
}


/**
 * converts bits into bytes and checks the parity! Returns byte or error accordingly.
 */
short alibaba_mimadecoder_fb::convertIntoBytes(std::vector<char> buffer)
{
        if(enable_parity_check_)
        {
                int parity_counter=0;
                for(int j=0;j<8;j++)
                {
                        if(buffer[j]==-1) //Manchester encoding error. Output the error and delete the whole byte.
                        {
                                return -1;
                        }
                        else 
                        if(buffer[j]==1) parity_counter++; //counter used for checking of correct parity
                }
                                                        
                if(buffer[8]==-1) //manchester encoding error. Output the error and delete the whole byte.
                {
                        return -1;
                }
                int mod_result= parity_counter%2; 
                if((mod_result==1 && buffer[8]==0) || (mod_result==0 && buffer[8]==1)) //odd parity matches
                {
                        unsigned char tmp_item=0;
                        tmp_item=tmp_item | buffer[0] | buffer[1] << 1 | buffer[2] << 2 | buffer[3] << 3 | buffer[4] << 4 | buffer[5] << 5 | buffer[6] << 6 | buffer[7] << 7;
                        return tmp_item;
                }
                else
                {
                        return(-2); //Parity check error!
                }
        }
        else
        {
                for(int j=0;j<8;j++)
                {
                        if(buffer[j]==-1) //Manchester encoding error. Output the error and delete the whole byte.
                        {
                                return -1;
                        }    
                }

                unsigned char tmp_item=0;
                tmp_item=tmp_item | buffer[0] | buffer[1] << 1 | buffer[2] << 2 | buffer[3] << 3 | buffer[4] << 4 | buffer[5] << 5 | buffer[6] << 6 | buffer[7] << 7;
                return(tmp_item);
        }
        return -2; //unreachable code! if so, parity check error is returned
}


/**
 * function that is called for decoding of blocks
 */
std::vector<short> alibaba_mimadecoder_fb::decodeBlock(std::vector<float> buffer, char encoding ,float threshold)
{
        std::vector<char> symbol_buffer;
        symbol_buffer.clear();
        std::vector<char> bit_buffer;
        bit_buffer.clear();
        std::vector<short> byte_buffer;
        byte_buffer.clear();
        int sample_counter=0;
        int ones_in_first_half=0;
        int ones_in_second_half=0;
        char symbol=0;
        bool first_byte=true;

        for(;;) //search for first one (start of frame). We don't care about leading zeros of a block...
        {
                if(buffer[0]>threshold || buffer.empty()) break;
                else
                        buffer.erase(buffer.begin());
        }

        for(int k=0;k<samples_per_symbol_;k++) //start bit has to be a one!
        {
                if(buffer.empty()) 
                {
                        byte_buffer.push_back(-1);
                        return byte_buffer; //block is too short to even hold a start bit
                }
                if(buffer[0] > threshold) symbol=1;
                else symbol=0;
                if(sample_counter < samples_per_symbol_)
                {
                        sample_counter++;
                        if((sample_counter <= rint(samples_per_symbol_/2)) && (symbol==1)) ones_in_first_half++;
                        if((sample_counter > rint(samples_per_symbol_/2)) && (symbol==1)) ones_in_second_half++;
                        buffer.erase(buffer.begin());
                        continue;
                }
                if(!(ones_in_first_half > ones_in_second_half))
                {
                        byte_buffer.push_back(-1); //Modified Miller or Manchester encoding error
                        return byte_buffer; //do not further process this block!
                }     
        }
        sample_counter=0; //delete counter for reading in next sample.
        ones_in_first_half=0;
        ones_in_second_half=0;

        while(!buffer.empty()) //handle the rest of the block
        {
                if(buffer[0] > threshold) symbol=1;
                else symbol=0;
                if(sample_counter < samples_per_symbol_)
                {
                        sample_counter++;
                        symbol_buffer.push_back(symbol);
                        if((sample_counter <= rint(samples_per_symbol_/2)) && (symbol==1)) ones_in_first_half++;
                        if((sample_counter > rint(samples_per_symbol_/2)) && (symbol==1)) ones_in_second_half++;
                        buffer.erase(buffer.begin());
                        continue;
                }
                if(encoding==ENCODING_MILLER)
                {
                        bit_buffer.push_back(decodeModifiedMiller(symbol_buffer,buffer,ones_in_first_half,ones_in_second_half));
                }
                else if(encoding==ENCODING_MANCHESTER)
                {
                        bit_buffer.push_back(decodeManchester(symbol_buffer,buffer,ones_in_first_half,ones_in_second_half));
                }
                else
                {
                        byte_buffer.push_back(-1);
                        return byte_buffer; //encoding is not supported!
                }
                symbol_buffer.clear();
                sample_counter=0; //delete counter for reading in next sample.
                ones_in_first_half=0;
                ones_in_second_half=0; 
                if(bit_buffer.size() >= 9) //one byte +parity
                {
                        byte_buffer.push_back(convertIntoBytes(bit_buffer));
                        bit_buffer.erase(bit_buffer.begin(), bit_buffer.begin()+9);
                        first_byte=false;
                }         
        }
        if(!symbol_buffer.empty())  //there is one last symbol
        {
                if(encoding==ENCODING_MILLER)
                {
                        bit_buffer.push_back(decodeModifiedMiller(symbol_buffer,buffer,ones_in_first_half,ones_in_second_half));
                }
                else if(encoding==ENCODING_MANCHESTER)
                {
                        bit_buffer.push_back(decodeManchester(symbol_buffer,buffer,ones_in_first_half,ones_in_second_half));
                }
                else
                {
                        byte_buffer.push_back(-1);
                        return byte_buffer; //encoding is not supported!
                }
        }
        if(bit_buffer.size() >= 9)  
        {
                byte_buffer.push_back(convertIntoBytes(bit_buffer));
                bit_buffer.clear();
                first_byte=false;
        }
        else if(bit_buffer.size()>=5 && first_byte==true) //mainly for ISO 14443 7 bit commands from reader! Req-A (0x26), Wake-up (0x52), optional time slot (0x35). But also all other data between 5 and seven bits long is accepted! 
        {
                short tmp_item=convertSevenBitCommandsIntoBytes(bit_buffer);
                if(tmp_item != 0) byte_buffer.push_back(tmp_item);
        }
        int block_size=byte_buffer.size();
        if(enable_crc_check_ && block_size>2) //blocks with size smaller than three can not have a CRC attached! 
        {
                for(int k=0;k<block_size;k++) 
                {
                        if(byte_buffer[k]<0) //there was a error in decoding or parity check! CRC will never match!
                        {
                                byte_buffer.push_back(-3);//CRC ERROR
                                return byte_buffer;
                        }
                }
                if(block_size==TAG_ID_LENGTH+1 && encoding==ENCODING_MANCHESTER) //Tag transmits ID without CRC, but one byte representing the XOR of previous bytes! 
                {
                        unsigned char xor_byte=byte_buffer[0]^byte_buffer[1];
                        for(int k=2;k<TAG_ID_LENGTH;k++) xor_byte=xor_byte^byte_buffer[k];
                        if(xor_byte==byte_buffer[block_size-1])
                        {
                                byte_buffer.pop_back(); //delete the xor byte and return the ID!
                                return byte_buffer;
                        }
                        else
                        {
                                byte_buffer.push_back(-3);
                                return byte_buffer;
                        }
                }
                unsigned char crc_array[block_size-2];
                unsigned char crc1=0;
                unsigned char crc2=0;
                std::copy(byte_buffer.begin(), byte_buffer.end()-2, crc_array);
                ComputeCrc(crc_array, block_size-2, &crc1, &crc2);
                if(crc1==byte_buffer[block_size-2] && crc2==byte_buffer[block_size-1]) //if CRC matches, delete the two CRC bytes from block, else keep them and append CRC Error.
                        byte_buffer.erase(byte_buffer.end()-2,byte_buffer.end());  //NOTE: CRC is checked but not deleted!
                else
                        byte_buffer.push_back(-3); //CRC ERROR
        }

        return byte_buffer;
}

/**
 * performs modified miller decoding
 */

char alibaba_mimadecoder_fb::decodeModifiedMiller(std::vector<char>& symbol_buffer,std::vector<float>& buffer, int ones_in_first_half, int ones_in_second_half)
{
                
        if((ones_in_first_half+ones_in_second_half) <= 2) //A binary zero. Two is for error correction
        {
                //for clock recovery reasons: synchronize the symbol. Delete leading zeros in stream!!!
                while(symbol_buffer[0]==1 && !symbol_buffer.empty() && !buffer.empty())
                {
                        buffer.erase(buffer.begin());
                        symbol_buffer.erase(symbol_buffer.begin());
                }
                return 0;
        }
        else if(ones_in_first_half > ones_in_second_half) //A binary zero!
        {
                //for clock recovery reasons: synchronize the symbol. Delete leading zeros in stream!!!
                while(symbol_buffer[0]==0 && !symbol_buffer.empty() && !buffer.empty())
                {
                        buffer.erase(buffer.begin());
                        symbol_buffer.erase(symbol_buffer.begin());
                }
                return 0;
        }
        else if(ones_in_first_half < ones_in_second_half) //A binary one!
        {
                return 1;
        }
        else
        {
                return -1;//modified Miller encoding error
        }

        return -1; //never reached code!
}


/**
 * performs manchester decoding.
 */
char alibaba_mimadecoder_fb::decodeManchester(std::vector<char>& symbol_buffer,std::vector<float>& buffer, int ones_in_first_half, int ones_in_second_half)
{   
        if(ones_in_first_half > ones_in_second_half) //A binary one!
        {
                //for clock recovery reasons: synchronize the symbol. Delete leading zeros in stream!!!
                while(symbol_buffer[0]==0 && !symbol_buffer.empty() && !buffer.empty())
                {
                        buffer.erase(buffer.begin());
                        symbol_buffer.erase(symbol_buffer.begin());
                }

                return 1;

        }
        else if(ones_in_first_half < ones_in_second_half) //A binary zero!
        {

                //for clock recovery reasons: synchronize the symbol. Delete leading ones in stream!!!
                while(symbol_buffer[0]==1 && !symbol_buffer.empty() && !buffer.empty())
                {
                        buffer.erase(buffer.begin());
                        symbol_buffer.erase(symbol_buffer.begin());
                }
                return 0;
               
        }
        else
        {
                return -1;//Manchester encoding error
        }   
 
        return -1; //never reached code!
}

/*
 * Our virtual destructor.
 */
alibaba_mimadecoder_fb::~alibaba_mimadecoder_fb ()
{
}

int alibaba_mimadecoder_fb::output_function(std::vector<short> *ob, short *out, int available_output_items, int out_counter)
{
        int tmp_size=ob->size();
        int min=std::min(tmp_size,available_output_items);
        if(min==0) return 0;
        if(tmp_size<=min)
        {
                std::copy(ob->begin(), ob->end(), &out[out_counter]);
                ob->clear();
        }
        else 
        {
                std::copy(ob->begin(), ob->begin()+min, &out[out_counter]);
                ob->erase(ob->begin(), ob->begin()+min);
        }
        return min;
}

int alibaba_mimadecoder_fb::check_manchester_encoding(std::vector<float> buff)
{
        int find_encoding_state=0; //synchronize state machine
        int encoding=ENCODING_MANCHESTER; //set encoding to Manchester encoding first...
        int num_symbols=0; //used for checking the number of symbols. Blocks with <7 Symbols are invalid. Only check for blocks with <=5 symbols to be sure to get all valid blocks! 
        double ones_counter=0;
        double zero_counter=0;
        double max_zeros=0;
        double max_ones=0;

        for(int j=0;j<buff.size();j++)
        {
                switch (find_encoding_state)
                {
                        case 0: if (buff[j]>thres_ma_) 
                                {
                                        find_encoding_state=1; //found a one
                                        ones_counter++;
                                }
                                break; 
                        case 1: if (buff[j]<thres_ma_) //a one followed by a zero
                                {
                                        find_encoding_state=2; 
                                        zero_counter=1;
                                }
                                else ones_counter++;
                                break;
                        case 2: if(buff[j]>thres_ma_) //a zero followed by a one
                                {
                                        //The longest zero or one period in Manchester coded data is one symbol period. Make sure, that there is room for frequency error!
                                        //if((zero_counter> rint(sampling_frequency_/data_rate_)+FREQUENCY_ERROR) || (ones_counter> rint(sampling_frequency_/data_rate_)+FREQUENCY_ERROR)) //sceme!=ENCODING_MILLER
                                        //{
                                        //        encoding=ENCODING_UNKNOWN;
                                        //}
                                        if(zero_counter>max_zeros) max_zeros=zero_counter;
                                        if(ones_counter>max_ones) max_ones=ones_counter;
                                        ones_counter=1;
                                        zero_counter=0;
                                        find_encoding_state=0;
                                        num_symbols++;
                                }
                                else zero_counter++;
                                break;
                        default: zero_counter=0;
                                 find_encoding_state=0;
          
                }
        }
        //check one last time for Manchester Encoding
        /*if((zero_counter> rint(sampling_frequency_/data_rate_)+FREQUENCY_ERROR) || (ones_counter> rint(sampling_frequency_/data_rate_)+FREQUENCY_ERROR) || num_symbols <=5) //sceme!=ENCODING_MILLER
        {
                encoding=ENCODING_UNKNOWN;
        }*/
        if((max_zeros > rint((sampling_frequency_/data_rate_)+FREQUENCY_ERROR)) || (max_ones> rint((sampling_frequency_/data_rate_)*1.5+FREQUENCY_ERROR)) || num_symbols <=5)
                encoding=ENCODING_UNKNOWN;
        return encoding;
}

int alibaba_mimadecoder_fb::check_modified_miller_encoding(std::vector<float> buff)
{
        int find_encoding_state=0; //synchronize state machine
        int encoding=ENCODING_MILLER; //set encoding to Manchester encoding first...
        int num_symbols=0; //used for checking the number of symbols. Blocks with <7 Symbols are invalid (a one followed by a zero can't be detected since there is no transition to indicate the zero period). So, only check for blocks with <=2 symbols to be sure to get all valid blocks! 
        double ones_counter=0;
        double zero_counter=0;
        double max_zeros=0;
        double max_ones=0;

        for(int j=0;j<buff.size();j++)
        {
                switch (find_encoding_state)
                {
                        case 0: if (buff[j]>thres_mi_) 
                                {
                                        find_encoding_state=1; //found a one
                                        ones_counter++;
                                }
                                break; 
                        case 1: if (buff[j]<thres_mi_) //a one followed by a zero
                                {
                                        find_encoding_state=2; 
                                        zero_counter=1;
                                }
                                else ones_counter++;
                                break;
                        case 2: if(buff[j]>thres_mi_) //a zero followed by a one
                                {
                                        //In Miller encoded data, the modulated periods (ones) in the signal are very short, and the unmodulated periods (zeros) are not more than one and a half signal period long...
                                        /*if(ones_counter > rint((sampling_frequency_/data_rate_)*0.7) || (zero_counter> rint((sampling_frequency_/data_rate_)*2))) //sceme!=ENCODING_MILLER. There are only very short periods of Modulation on the signal...
                                        {
                                                encoding=ENCODING_UNKNOWN;
                                        }*/
                                        if(zero_counter>max_zeros) max_zeros=zero_counter;
                                        if(ones_counter>max_ones) max_ones=ones_counter;
                                        ones_counter=1;
                                        zero_counter=0;
                                        find_encoding_state=0;
                                        num_symbols++; //the change in treshold indicates that one symbol was handled...
                                }
                                else zero_counter++;
                                break;
                        default: zero_counter=0;
                                 find_encoding_state=0;
          
                }
        }
        /*if(ones_counter > rint((sampling_frequency_/data_rate_)*0.7) || (zero_counter> rint((sampling_frequency_/data_rate_)*2)) || num_symbols <=2) //check one last time for sceme!=ENCODING_MILLER.
        {
                encoding=ENCODING_UNKNOWN;
        }*/
        if((max_zeros > rint((sampling_frequency_/data_rate_)*2+FREQUENCY_ERROR)) || (max_ones> rint((sampling_frequency_/data_rate_)*0.7)) || num_symbols <=2)
                encoding=ENCODING_UNKNOWN;
        return encoding;
}

int 
alibaba_mimadecoder_fb::general_work (int noutput_items,
			       gr_vector_int &ninput_items,
			       gr_vector_const_void_star &input_items,
			       gr_vector_void_star &output_items)
{
  const float *in = (const float *) input_items[0];
  short *out = (short *) output_items[0];


  int initial_fill_number=5;
  int out_counter=0;
  int items_written=0;


  if(!out_buffer.empty() && split_block==true) //check, if there is still data from previous call!
  {
        int items_avail=noutput_items-out_counter;
        items_written= output_function(&out_buffer, out, items_avail, out_counter);  //out counter should be 0 here!
        out_counter+=items_written;
        if(items_written==items_avail)
        {
                consume_each (0); //we haven't consumed one single input item yet!
                return out_counter;
        }
        else
        {
                state=0;
                split_block=false;
                out_buffer.clear();  
                tmp_out_buffer.clear(); 
        }
  }

  
  for (int i = 0; i < noutput_items; i++)
  {

        if(!initial_fill)
        {
              tmp_buffer.push_back(in[i]);
              initial_fill_count++; 
              if(initial_fill_count>=initial_fill_number)
                initial_fill=true;
              continue;
        }
        else
        {
         tmp_buffer.push_back(in[i]);
        }
        switch (state)
        {
                case 0: if(tmp_buffer[0]==separation_val_) 
                        {
                                state=1;
                                encoding_scheme=ENCODING_UNKNOWN; //first try Miller encoding!
                        }
                        tmp_buffer.erase(tmp_buffer.begin());
                        break;
                case 1: tmp_out_buffer.push_back(tmp_buffer[0]);   //can't convert into binary here, because offset for manchester and miller is different!
                        if(tmp_buffer[1]==separation_val_) 
                        {
                                encoding_scheme= check_modified_miller_encoding(tmp_out_buffer); //Miller is easier to detect. Exclude Miller blocks first, then try Manchester decoding. 
                                if(encoding_scheme==ENCODING_UNKNOWN) encoding_scheme= check_manchester_encoding(tmp_out_buffer);  
                                
                                

                                //output values here!
                                if(encoding_scheme==ENCODING_MILLER && (decode_miller_or_manchester_==ENCODING_MILLER || decode_miller_or_manchester_==0))
                                {
                                        out_buffer=decodeBlock(tmp_out_buffer, encoding_scheme, thres_mi_);
                                        if(!out_buffer.empty()) out_buffer.insert(out_buffer.begin(),separation_value_for_miller_);
                                }
                                else if(encoding_scheme==ENCODING_MANCHESTER && (decode_miller_or_manchester_==ENCODING_MANCHESTER ||decode_miller_or_manchester_==0))
                                {
                                        out_buffer=decodeBlock(tmp_out_buffer, encoding_scheme, thres_ma_);
                                        if(!out_buffer.empty()) 
                                        {
                                                out_buffer.insert(out_buffer.begin(),separation_value_for_manchester_); //Insert a seperation value at the beginning and at the end of a block!                              
                                        }
                                }
                                else
                                {
                                        out_buffer.clear(); //Unknown Encoding is ignored!
                                        out_buffer.push_back(-4);
                                }

                                int items_avail=noutput_items-out_counter;
                                items_written= output_function(&out_buffer, out, items_avail, out_counter);
                                out_counter+=items_written;
                                if(items_written==items_avail)
                                {
                                        if(!out_buffer.empty()) split_block=true;
                                }
                                else
                                {
                                        state=0;
                                        split_block=false;
                                        out_buffer.clear(); 
                                        tmp_out_buffer.clear();  
                                }
                                tmp_buffer.erase(tmp_buffer.begin());//we don't need that item any more!
                                consume_each (i+1);
                                return out_counter;
                        }
                        tmp_buffer.erase(tmp_buffer.begin());
                        break;
                default: state=0;
                         out_buffer.clear();
                         tmp_out_buffer.clear();
  
        }

  }

  // Tell runtime system how many input items we consumed on
  // each input stream.

  consume_each (noutput_items);

  // Tell runtime system how many output items we produced.
  return out_counter;
}

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <alibaba_fsk_demodulator_fb.h>
#include <gr_io_signature.h>

/*
 * Create a new instance of alibaba_fsk_demodulator_fb and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
alibaba_fsk_demodulator_fb_sptr 
alibaba_make_fsk_demodulator_fb (float sampling_frequency, float frequency_one, float frequency_zero)
{
  return alibaba_fsk_demodulator_fb_sptr (new alibaba_fsk_demodulator_fb (sampling_frequency, frequency_one, frequency_zero));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 1;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
alibaba_fsk_demodulator_fb::alibaba_fsk_demodulator_fb (float sampling_frequency, float frequency_one, float frequency_zero)
  : gr_block ("demodulator_fb",
	      gr_make_io_signature (MIN_IN, MAX_IN, sizeof (float)),
	      gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (char)))
{
	sampl_freq=sampling_frequency;
	freq_one=frequency_one;
	freq_zero=frequency_zero; 
        initial_fill=false;
        initial_fill_count=0;
        //just to be sure, that vectors are empty;
        tmp_buffer.clear();
        counter=0;

        num_samples_one= rint(sampl_freq/freq_one);
        num_samples_zero = rint(sampl_freq/freq_zero);
        maximum=std::max(num_samples_one,num_samples_zero);

}

/*
 * Our virtual destructor.
 */
alibaba_fsk_demodulator_fb::~alibaba_fsk_demodulator_fb ()
{
}

int 
alibaba_fsk_demodulator_fb::general_work (int noutput_items,
			       gr_vector_int &ninput_items,
			       gr_vector_const_void_star &input_items,
			       gr_vector_void_star &output_items)
{
  const float *in = (const float *) input_items[0];
  char *out = (char *) output_items[0];

  int out_counter=0;
  

  //The samples till the next neg/pos signal transition are counted 
  //and the modulator is triggered to the number of samples per frequency plus a offset (room for frequency error...). 
  //Works surprisingly well :)
  for (int i = 0; i < noutput_items; i++)
  {
    
    //to handle the stream nature of the general work method, it has to be ensured,
    //that sequences splitted by two calls of general work still are recognized.
    //to handle this problem, a buffer was implemented that bufferes some samples.  
    if(!initial_fill)
    {
          tmp_buffer.push_back(in[i]);
          initial_fill_count++; 
          if(initial_fill_count>=2)
              initial_fill=true;
          continue;
    }
    else
    {
           tmp_buffer.push_back(in[i]);
    }

    if(counter> maximum*10) //to avoid counter overflow...
        counter=1;
    else
        counter++;
    if(tmp_buffer[0]<=0 && tmp_buffer[1]>=0)
    {
	if((counter>=(num_samples_one-3)) && (counter<=(num_samples_one+3)))
	{
		out[out_counter]=1;
		out_counter++;
	}
	if((counter>(num_samples_zero-3)) && (counter<(num_samples_zero+3)))
	{
		out[out_counter]=0;
		out_counter++;
	}
        counter=0;
    }
    tmp_buffer.erase(tmp_buffer.begin());
  }

  // Tell runtime system how many input items we consumed on
  // each input stream.

  consume_each (noutput_items);

  // Tell runtime system how many output items we produced.
  return out_counter;
}

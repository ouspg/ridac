/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <alibaba_checkid_bb.h>
#include <gr_io_signature.h>

/*
 * Create a new instance of fsk_demodulator_fb and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
alibaba_checkid_bb_sptr 
alibaba_make_checkid_bb (std::vector<char> starting_sequence, int how_many_equals)
{
  return alibaba_checkid_bb_sptr (new alibaba_checkid_bb (starting_sequence, how_many_equals));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 1;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
alibaba_checkid_bb::alibaba_checkid_bb (std::vector<char> starting_sequence, int how_many_equals)
  : gr_block ("checkid_bb",
	      gr_make_io_signature (MIN_IN, MAX_IN, sizeof (char)),
	      gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (char)))
{
	start_seq=starting_sequence;
	num_equals=how_many_equals;
	found_id=false;
        //just to be sure, that vectors are empty
        initial_id.clear();
        id_to_compare.clear();
        tmp_buffer.clear();        
        //counts how many equal ids could be found
        number_of_matches=0;
        //used to determine the current state of the state machine.
        state=0;
        initial_fill=false;
        initial_fill_count=0;

        buffer_size=start_seq.size()*2;
        transponder_id.clear();
}

bool alibaba_checkid_bb::check_start_sequence(std::vector<char> sequence, std::vector<char> sequence_to_check)
{
        for(int i=0;i<sequence.size();i++)
        {
                if(sequence[i]!=sequence_to_check[i]) return false;
        }     

        return true;
}

bool alibaba_checkid_bb::get_found_id()
{
     return found_id;
}

std::vector<char> alibaba_checkid_bb::get_transponder_ID()
{
        return transponder_id;
}

/*
 * Our virtual destructor.
 */
alibaba_checkid_bb::~alibaba_checkid_bb ()
{
}

std::vector<char> alibaba_checkid_bb::decodeID(std::vector<char> id, int start_seq_size)
{
        std::vector<char> decoded_id;
        for(int i=0;i<start_seq_size;i++)
        {
                id.erase(id.begin());
        }
        while(!id.empty())
        {
             if(id.size()>1)
             {
                if(id[0]==1 && id[1]==0) decoded_id.push_back(1);
                else if(id[0]==0 && id[1]==1) decoded_id.push_back(0);
                id.erase(id.begin(),id.begin()+2);
             }
             else id.clear();
              
        }
        return decoded_id;
}

int 
alibaba_checkid_bb::general_work (int noutput_items,
			       gr_vector_int &ninput_items,
			       gr_vector_const_void_star &input_items,
			       gr_vector_void_star &output_items)
{
  const char *in = (const char *) input_items[0];
  char *out = (char *) output_items[0];
  
  int initial_fill_number=std::min(buffer_size, noutput_items);
   

  for (int i = 0; i < noutput_items; i++)
  {
        //to handle the stream nature of the general work method, it has to be ensured,
        //that start sequences splitted by two calls of general work still are recognized.
        //to handle this problem, a buffer was implemented, that always holds a number of
        //items bigger than the start sequence.  
        if(!initial_fill)
        {
              tmp_buffer.push_back(in[i]);
              initial_fill_count++; 
              if(initial_fill_count>=initial_fill_number)
                initial_fill=true;
              continue;
        }
        else
        {
              tmp_buffer.push_back(in[i]);
        }


        if(tmp_buffer.size()>start_seq.size()) //should always be given, because of the initial fill requirement! If not, just wait until it is filled...
        {
                
                //Implementation of a state machine to find out repeating IDs.
                //State 0: find first start sequence
                //State 1: store first id in a vector
                //State 2: store the id to compare in another vector
                //State 3: compare the vectors. check if they already repeated enough or if it has to be repeated more
                //State 4: output ID and signal that an id was found
                //State 5: ensure that the module stops... 
                switch (state)
                {
                        case 0: if(check_start_sequence(start_seq, tmp_buffer)) 
                                {
                                        state=1;
                                        initial_id.clear(); //just to be sure!
                                        initial_id.push_back(tmp_buffer[0]);
                                }
                                tmp_buffer.erase(tmp_buffer.begin());
                                break; 
                        case 1: initial_id.push_back(tmp_buffer[0]);
                                if(check_start_sequence(start_seq, tmp_buffer))
                                {
                                        state=2;
                                        initial_id.pop_back();
                                        id_to_compare.clear(); //just to be shure!
                                        id_to_compare.push_back(tmp_buffer[0]);           
                                }
                                tmp_buffer.erase(tmp_buffer.begin());
                                break;
                        case 2: id_to_compare.push_back(tmp_buffer[0]);
                                if(check_start_sequence(start_seq, tmp_buffer))
                                {
                                        state=3;
                                        id_to_compare.pop_back();
                                        break; //first item in tmp buffer must not be deleted, if id is repeated another time!
                                }
                                tmp_buffer.erase(tmp_buffer.begin());
                                break;
                        case 3: if(id_to_compare==initial_id)
                                {
                                        id_to_compare.clear();
                                        number_of_matches++;
                                        if(number_of_matches>=num_equals) state=4;
                                        else
                                        {
                                                state=2;
                                                id_to_compare.push_back(tmp_buffer[0]);
                                                tmp_buffer.erase(tmp_buffer.begin());
                                        }
                                }
                                else
                                {
                                        state=0;
                                        id_to_compare.clear();
                                        initial_id.clear();
                                }
                                break;
                        case 4: transponder_id=decodeID(initial_id,start_seq.size());
                                for (int j=0;j<initial_id.size();j++) out[j]=initial_id[j];
                                consume_each (i);
                                state=5;
                                found_id=true;
                                return initial_id.size();
                        case 5: return -1; //at that point the id was already found!
                        default: state=0;
                                 id_to_compare.clear();
                                 initial_id.clear();
                                 tmp_buffer.clear();
                                 initial_fill=false;
                                 initial_fill_count=0;
                }
        }
  }

       

  // Tell runtime system how many input items we consumed on
  // each input stream.

  consume_each (noutput_items);

  // Tell runtime system how many output items we produced.
  return 0;
}
